const rawHeaderLen = 16
const packetOffset = 0
const headerOffset = 4
const verOffset = 6
const opOffset = 8
const seqOffset = 12
const MAX_CONNECT_TIMES = 10 //最大重连次数
const DELAY = 5000          //每隔5秒连一次 
var ReconnectingWebSocket = {
    obj:null,
    url:"ws://domain.com/sub",
    token:null,
    msgSeq : 0,
    ws : null,
    room_id:null,
    textDecoder : null,
    textEncoder : null,
    heartbeatInterval : null,  //定时器句柄 
    init : function(url, token, obj){
        var self = this
        self.url = url
        self.obj = obj
        self.token = token
        self.textDecoder = new TextDecoder()
        self.textEncoder = new TextEncoder()

        self.createConnect(MAX_CONNECT_TIMES, DELAY)
        return self
    }, 
    createConnect : function (max, delay) {
        var self = this
        if (max === 0) {
            return
        }

        var ws = new WebSocket(self.url)
        ws.binaryType = 'arraybuffer'
        ws.onopen = function() {
            self.auth(ws)  
            if (self.room_id) { // 重连的时候 先订阅房间
                self.sub(self.room_id)
            }
        }
        ws.onmessage = function(evt) {
            var data = evt.data
            var dataView = new DataView(data, 0)
            var packetLen = dataView.getInt32(packetOffset)
            var headerLen = dataView.getInt16(headerOffset)
            var ver = dataView.getInt16(verOffset)
            var op = dataView.getInt32(opOffset)
            var seq = dataView.getInt32(seqOffset) 
            //console.log("receiveHeader: packetLen=" + packetLen, "headerLen=" + headerLen, "ver=" + ver, "op=" + op, "seq=" + seq)
            switch(op) {
                case 8: // 认证成功的结果// auth reply ok 
                    console.log("receive 8: 回 认证成功")   
                    self.heartbeat(ws) 
                    self.heartbeatInterval = setInterval(function(){
                        self.heartbeat(ws)
                    }, 27 * 1000)
                    break
                case 3: //心跳包成功的结果 
                    break
                case 13: //订阅房间的结果
                    console.log("receive 13: 回 订阅房间成功")   
                    //self.sync(ws)
                    break
                case 17: // 取消订阅的结果 
                    console.log("receive 13: 回 取消订阅成功")   
                    break
                case 19: //sync 同步历史消息
                    var msgBody = self.textDecoder.decode(data.slice(headerLen, packetLen))
                    console.log("receive 19:回  同步历史消息: ver=" + ver + " op=" + op + " seq=" + seq + " message=" + msgBody)
                    //self.syncMsgReceived(ws, msgBody)
                    break
                case 21: //消息偏移上报的结果
                    console.log("receive 21: 回  消息偏移上报的结果") 
                    break
                case 9: 
                    // batch message 原始消息 比如 TLV  中的 V (body体)又是一个 TLV 结构
                    var offset = rawHeaderLen 
                    for (; offset<data.byteLength; offset+=packetLen) {
                        // parse
                        var packetLen = dataView.getInt32(offset)
                        var headerLen = dataView.getInt16(offset+headerOffset)
                        var ver = dataView.getInt16(offset+verOffset)
                        var op = dataView.getInt32(offset+opOffset)
                        var seq = dataView.getInt32(offset+seqOffset)
                        var msgBody = self.textDecoder.decode(data.slice(offset+headerLen, offset+packetLen))
                        // callback 
                        console.log("receive 9: 回原生消息 ver=" + ver + " op=" + op + " seq=" + seq + " message=" + msgBody)
                        self.messageReceived(ws, msgBody) 
                    }
                    break
                case 5:
                    var msgBody = self.textDecoder.decode(data.slice(headerLen, packetLen))
                    console.log("receive 5: 回发送消息响应 ver=" + ver + " op=" + op + " seq=" + seq + " message=" + msgBody)
                    self.messageReceived(ws, msgBody)
                    break
                default:
                    // TODO
                    console.log("未知消息响应: packetLen=" + packetLen, "headerLen=" + headerLen, "ver=" + ver, "op=" + op, "seq=" + seq)
            }
        }

        ws.onclose = function() {
            if (self.heartbeatInterval) clearInterval(self.heartbeatInterval);
            setTimeout(reConnect, delay)
            console.log("连接异常...")
        }
        function reConnect() {
            self.createConnect(--max, delay) 
        } 

        self.ws = ws
    }, 
    sub : function (room_id) { //订阅房间
        var self = this
        self.room_id = room_id
        var headerBuf = new ArrayBuffer(rawHeaderLen) //分配16个固定元素大小
        var headerView = new DataView(headerBuf, 0) //读写时手动设定字节序的类型
        var bodyBuf = self.textEncoder.encode(room_id)
        headerView.setInt32(packetOffset, rawHeaderLen + bodyBuf.byteLength) //写入从内存的第0个字节序开始  值为16
        headerView.setInt16(headerOffset, rawHeaderLen) //写入从内存的第4个字节序开始  值为16
        headerView.setInt16(verOffset, 1)  //写入从内存的6第个字节序开始，值为1     省去的第三个参数: true为小端字节序，false为大端字节序 不填为大端字节序
        headerView.setInt32(opOffset, 12)   //写入从内存的8第个字节序开始，值为2
        headerView.setInt32(seqOffset, 1)  //写入从内存的12第个字节序开始，值为1 
        var flag = self.ws.send(self.mergeArrayBuffer(headerBuf, bodyBuf))
        return flag
    },
    messageAck : function (ws, deviceId, roomId, id) { //TODO
        var self = this
        var dst = {
            key :deviceId,
            room_id :roomId,
            id:id
        }
        var token = JSON.stringify(dst)
        var headerBuf = new ArrayBuffer(rawHeaderLen) //分配16个固定元素大小
        var headerView = new DataView(headerBuf, 0) //读写时手动设定字节序的类型
        var bodyBuf = self.textEncoder.encode(token)
        headerView.setInt32(packetOffset, rawHeaderLen + bodyBuf.byteLength) //写入从内存的第0个字节序开始  值为16
        headerView.setInt16(headerOffset, rawHeaderLen) //写入从内存的第4个字节序开始  值为16
        headerView.setInt16(verOffset, 1)  //写入从内存的6第个字节序开始，值为1     省去的第三个参数: true为小端字节序，false为大端字节序 不填为大端字节序
        headerView.setInt32(opOffset, 20)   //写入从内存的8第个字节序开始，值为2
        headerView.setInt32(seqOffset, 1)  //写入从内存的12第个字节序开始，值为1 
        var flag = ws.send(self.mergeArrayBuffer(headerBuf, bodyBuf))
        return flag
    },
    heartbeat : function (ws) {
        var headerBuf = new ArrayBuffer(rawHeaderLen)  
        var headerView = new DataView(headerBuf, 0)  
        headerView.setInt32(packetOffset, rawHeaderLen)  
        headerView.setInt16(headerOffset, rawHeaderLen)  
        headerView.setInt16(verOffset, 1)  
        headerView.setInt32(opOffset, 2)
        headerView.setInt32(seqOffset, 1)  
        ws.send(headerBuf) 
       // this.sendMsg(ws) 测试不走ajax 发送消息
    },
    sendMsg : function (token) {
        var self = this
        //var token = '{"user_id":13000000000, "shop_id":1645755332, "type":"text", "msg":"++++++++++++++测试++++++++++++++++++", "room_id":"1645755332", "dateline":1645776553, "id":"1645776553444263000"}' 
        token = JSON.stringify(token)
        var headerBuf = new ArrayBuffer(rawHeaderLen) 
        var headerView = new DataView(headerBuf, 0)
        var bodyBuf = self.textEncoder.encode(token) //接收一个String类型的参数返回一个Unit8Array 1个字节
        headerView.setInt32(packetOffset, rawHeaderLen + bodyBuf.byteLength) //包长度  写入从内存的第0个字节序开始  值为16 + token长度
        headerView.setInt16(headerOffset, rawHeaderLen) //写入从内存的第4个字节序开始  值为16
        headerView.setInt16(verOffset, 1) //版本号为1
        headerView.setInt32(opOffset, 4)  //写入从内存的8第个字节序开始，值为7 标识auth
        headerView.setInt32(seqOffset, 1) //从内存的12个字节序开始· 值为1   序列号（服务端返回和客户端发送一一对应）
        var flag = self.ws.send(self.mergeArrayBuffer(headerBuf, bodyBuf))
       
        return flag
    },
    sync : function (ws) {
        var self = this
        var dst = {
            page:1,
            op : self.obj.user.accepts[0],
            key : self.obj.user.key,
            room_id : self.obj.user.room_id  
        }
        var token = JSON.stringify(dst)

        var headerBuf = new ArrayBuffer(rawHeaderLen)  
        var headerView = new DataView(headerBuf, 0)  
        var bodyBuf = self.textEncoder.encode(token)

        headerView.setInt32(packetOffset, rawHeaderLen + bodyBuf.byteLength)  
        headerView.setInt16(headerOffset, rawHeaderLen)  
        headerView.setInt16(verOffset, 1)  
        headerView.setInt32(opOffset, 18)
        headerView.setInt32(seqOffset, 1)  
     
        return ws.send(self.mergeArrayBuffer(headerBuf, bodyBuf))
    },

    auth: function (ws) {
        var self = this
        //协议格式对应 /api/comet/grpc/protocol
        //var token = '{"user_id":123, "room_id":"live://1000", "platform":"web", "accepts":[1000,1001,1002]}'
        var token = JSON.stringify(self.token)
        console.log(token)
        var headerBuf = new ArrayBuffer(rawHeaderLen) 
        var headerView = new DataView(headerBuf, 0)
        var bodyBuf = self.textEncoder.encode(token) //接收一个String类型的参数返回一个Unit8Array 1个字节
        headerView.setInt32(packetOffset, rawHeaderLen + bodyBuf.byteLength) //包长度  写入从内存的第0个字节序开始  值为16 + token长度
        headerView.setInt16(headerOffset, rawHeaderLen) //写入从内存的第4个字节序开始  值为16
        headerView.setInt16(verOffset, 1) //版本号为1
        headerView.setInt32(opOffset, 7)  //写入从内存的8第个字节序开始，值为7 标识auth
        headerView.setInt32(seqOffset, 1) //从内存的12个字节序开始· 值为1   序列号（服务端返回和客户端发送一一对应）
        var flag = ws.send(self.mergeArrayBuffer(headerBuf, bodyBuf))
        //console.log("send: auth token: " + token)
        return flag
    }, 
    syncMsgReceived :  function (body) {
        if (body.length < 2) {
            return
        }
        var self = this
        var shows = JSON.parse(body)
        if (shows) {
            for(var i=0;i<shows.length; i++){
                self.obj.OnMessage(shows[i])
            }
        }
    },
    messageReceived :  function (ws, body) {
        if (body.length < 2) {
            return
        }
        var self = this
        var key = self.obj.user.key
        var room_id =  self.obj.user.room_id
         
        //console.log("-------------->",body)
        var dst = JSON.parse(body)
        if (dst instanceof Array) {
            for(var i=0;i<dst.length; i++){
                self.obj.OnMessage(dst[i])
            }
        } else{
            self.obj.OnMessage(dst)
            self.messageAck(ws, key, room_id, dst.id) //上报 消息偏移
            //console.log( "--上报 消息偏移 --show.id-->" + show.id + " ---self.msgSeq-->" + self.msgSeq )  
        }
    },
    mergeArrayBuffer : function (ab1, ab2) {
        var u81 = new Uint8Array(ab1), u82 = new Uint8Array(ab2),
            res = new Uint8Array(ab1.byteLength + ab2.byteLength)
        res.set(u81, 0)
        res.set(u82, ab1.byteLength)
        return res.buffer
    },
}
